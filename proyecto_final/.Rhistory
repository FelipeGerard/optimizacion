install.packges('snow')
install.packages('snow')
library(snow)
cl <- makeCluster(2, type = "MPI")
?makeCluster
getClusterOption("type")
install.packages('Rmpi')
install.packages('Rmpi', type = 'source')
remove.packages(Rmpi)
remove.packages('Rmpi')
install.packages("Rmpi", type="source",
configure.args="--with-mpi=/Users/Felipe/algoritmos-de-gran-escala/paquetes/OMPI")
install.packages("Rmpi", type="source")
install.packages("Rmpi", type="source")
library(snow)
cl <- makeCluster(2, type = "MPI")
clusterEvalQ(cl, Sys.getenv("HOST"))
clusterApply(cl, 1:2, function(x) x+1)
clusterApply(cl, 1:6, function(x) x+1)
cl
getwd()
source('src/paralelo/puntosInteriores.R')
library(Matrix)
library(parallel)
options(digits <- 16)
options(digits = 16)
Train <- read.csv('src/paralelo/Train.csv',stringsAsFactors <- F,header <- F)
Train <- read.csv('src/paralelo/Train.csv', stringsAsFactors = F, header = F)
dim(Train)
dim_Train <- dim(Train)
m <- dim_Train[1]
n <- dim_Train[2]
source('src/paralelo/puntosInteriores.R')
library(Matrix)
library(parallel)
options(digits = 16)
#lectura de datos de entrenamiento
Train <- read.csv('src/paralelo/Train.csv', stringsAsFactors = F, header = F)
dim_Train <- dim(Train)
m <- dim_Train[1]
n <- dim_Train[2]
X_est <- scale(Train[,2:n], center = T, scale = T);
X_est <- t(X_est);
ind <- Train[,1] == 0;
b <- Train[,1];
b[ind] <- -1;
n <- n-1;
Y <- .sparseDiagonal(length(b),b)
A <- Matrix(X_est%*%Y,sparse = T);
e <- (vector('numeric',m)+1)
Ay <- rBind(.sparseDiagonal(n,1),0)
Ax <- rBind(-A,-t(b))
C <- 1e3;
x <- (C/2)*e;
y <- A%*%x;
v <- x;
s <- x;
lambda <- rBind(y,1);
Amod <- Matrix(cBind(Ay,Ax),sparse = T)
mu <- as.numeric((t(x)%*%s+t(C*e-x)%*%v)/(2*m));
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
resPI <- puntosinteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
resPI <- puntosinteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
source('src/paralelo/puntosInteriores.R')
resPI <- puntosinteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
stopCluster(cl)
library(snow)
cl <- makeCluster(2, type = "MPI")
stopCluster(cl)
library(snow)
cl <- makeCluster(2, type = "MPI")
clusterEvalQ(cl, Sys.getenv("HOST"))
library(snow)
cl <- makeCluster(2, type = "MPI")
clusterEvalQ(cl, ls())
stopCluster(cl)
?parallel::clusterExport
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
#Puntos interiores:
#Si se desea secuencial escribir FALSE, si se desea paralelo escribir TRUE
resPI <- puntosinteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
#Puntos interiores:
#Si se desea secuencial escribir FALSE, si se desea paralelo escribir TRUE
resPI <- puntosInteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
source('src/paralelo/puntosInteriores.R')
library(Matrix)
library(parallel)
options(digits = 16)
#lectura de datos de entrenamiento
Train <- read.csv('src/paralelo/Train.csv', stringsAsFactors = F, header = F)
#Asignaci贸n de variables de acuerdo a la nomenclatura de Puntos Interiores (2a versi贸n)
dim_Train <- dim(Train)
m <- dim_Train[1]
n <- dim_Train[2]
X_est <- scale(Train[,2:n], center = T, scale = T);
X_est <- t(X_est);
ind <- Train[,1] == 0;
b <- Train[,1];
b[ind] <- -1;
n <- n-1;
Y <- .sparseDiagonal(length(b),b)
A <- Matrix(X_est%*%Y,sparse = T);
e <- (vector('numeric',m)+1)
Ay <- rBind(.sparseDiagonal(n,1),0)
Ax <- rBind(-A,-t(b))
#Puntos iniciales para PI
C <- 1e3;
x <- (C/2)*e;
y <- A%*%x;
v <- x;
s <- x;
lambda <- rBind(y,1);
Amod <- Matrix(cBind(Ay,Ax),sparse = T)
mu <- as.numeric((t(x)%*%s+t(C*e-x)%*%v)/(2*m));
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
#Puntos interiores:
#Si se desea secuencial escribir FALSE, si se desea paralelo escribir TRUE
resPI <- puntosInteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
getwd()
source('src/paralelo/puntosInteriores.R')
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
#Puntos interiores:
#Si se desea secuencial escribir FALSE, si se desea paralelo escribir TRUE
resPI <- puntosInteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
ls()
rm(puntosinteriores)
source('src/paralelo/puntosInteriores.R')
library(Matrix)
library(parallel)
options(digits = 16)
#lectura de datos de entrenamiento
Train <- read.csv('src/paralelo/Train.csv', stringsAsFactors = F, header = F)
#Asignaci贸n de variables de acuerdo a la nomenclatura de Puntos Interiores (2a versi贸n)
dim_Train <- dim(Train)
m <- dim_Train[1]
n <- dim_Train[2]
X_est <- scale(Train[,2:n], center = T, scale = T);
X_est <- t(X_est);
ind <- Train[,1] == 0;
b <- Train[,1];
b[ind] <- -1;
n <- n-1;
Y <- .sparseDiagonal(length(b),b)
A <- Matrix(X_est%*%Y,sparse = T);
e <- (vector('numeric',m)+1)
Ay <- rBind(.sparseDiagonal(n,1),0)
Ax <- rBind(-A,-t(b))
#Puntos iniciales para PI
C <- 1e3;
x <- (C/2)*e;
y <- A%*%x;
v <- x;
s <- x;
lambda <- rBind(y,1);
Amod <- Matrix(cBind(Ay,Ax),sparse = T)
mu <- as.numeric((t(x)%*%s+t(C*e-x)%*%v)/(2*m));
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
#Puntos interiores:
#Si se desea secuencial escribir FALSE, si se desea paralelo escribir TRUE
resPI <- puntosInteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
resPI
resPI <- puntosInteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,F)
resPI <- puntosInteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,T)
a <- matrix(1:20,5,4)
a
split(a, c(1,1,1,2,2,2))
split(a, c(1,1,1,2,2))
split(a, c(1,1,1,2,2))
split(as.data.frame(a), c(1,1,1,2,2))
a
n <- 20
p <- 6
rep(1:p, each=floor(n/p))
rep(1:p, each=floor(n/p))
u <- floor(n/p)
u
p*u
c(rep(1:p, each=u), rep(p,n-u*p))
detach('package:snow',unload=T)
?clusterApply
library(dplyr)
a
f
split(a, c(1,1,1,3,3))
split(a, c(1,1,1,3,3))
?split
n
p
fac
fac <- c(rep(1:p, each=u), rep(p,n-u*p))
fac
fac==3
which(fac==3)
source('src/paralelo/puntosInteriores.R')
cat(sprintf('   i    |F|       |rcx1|        |rb|          |f3|        |f4|          obj          mu        alfa       cond\n'))
#Puntos interiores:
#Si se desea secuencial escribir FALSE, si se desea paralelo escribir TRUE
resPI <- puntosInteriores(m,n,Amod,Ax,Ay,e,b,C,1e-6,.1,x,y,s,v,lambda,mu,0,TRUE)
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
debugSource('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
warnings()
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
?do.call
do.call('+', 1:4)
do.call('+', list(1:4))
do.call('+', list(1,2,3,4))
do.call('+', list(1,2,3,4), list(3,4,5,6))
do.call('+', list(c(1,1),c(2,2),c(3,3)))
do.call(sum, list(c(1,1),c(2,2),c(3,3)))
list(c(1,1),c(2,2),c(3,3))
do.call(function(x,y) x+y, list(1,2))
do.call(function(x,y) x+y, list(1,2,3,4))
nargs(fun1)
nargs(sum)
nargs
nargs()
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
ejecutar.tarea
C
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
list(1,2)
c(list(1,2),3)
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
c(list(1,2),3)
c(list(1,2),a=3)
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
source('~/algoritmos-de-gran-escala/proyecto_final/src/paralelo/Script.R')
